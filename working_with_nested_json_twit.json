use role sysadmin;

create database SOCIAL_MEDIA_FLOODGATES;

-- Create table with one column for json format (variant) 
create or replace table SOCIAL_MEDIA_FLOODGATES.public.TWEET_INGEST 
(
RAW_STATUS variant
);

-- Create File Format for JSON Data 
create or replace file format SOCIAL_MEDIA_FLOODGATES.public.json_file_format
type = 'JSON' 
compression = 'AUTO' 
enable_octal = FALSE
allow_duplicate = FALSE 
strip_outer_array = TRUE --to ignore the square brackets and load each author into a separate row
strip_null_values = FALSE 
ignore_utf8_errors = FALSE; 

-- See the result before loading to table 
select $1
from @util_db.public.my_internal_stage/nutrition_tweets.json
(file_format => library_card_catalog.public.json_file_format);

-- Load to table usin the format for json 
copy into SOCIAL_MEDIA_FLOODGATES.public.TWEET_INGEST 
from @util_db.public.my_internal_stage
files = ('nutrition_tweets.json')
file_format = ( format_name = library_card_catalog.public.json_file_format );

-- Query the Nested JSON Data
-- all data 
select RAW_STATUS
from SOCIAL_MEDIA_FLOODGATES.public.TWEET_INGEST;

--simple select statements -- are you seeing 9 rows?
select raw_status
from tweet_ingest;

select raw_status:entities
from tweet_ingest;

select raw_status:entities:hashtags
from tweet_ingest;

--Explore looking at specific hashtags by adding bracketed numbers
--This query returns just the first hashtag in each tweet
select raw_status:entities:hashtags[0].text
from tweet_ingest;

--This version adds a WHERE clause to get rid of any tweet that 
--doesn't include any hashtags
select raw_status:entities:hashtags[0].text
from tweet_ingest
where raw_status:entities:hashtags[0].text is not null;

--Perform a simple CAST on the created_at key
--Add an ORDER BY clause to sort by the tweet's creation date
select raw_status:created_at::date
from tweet_ingest
order by raw_status:created_at::date;

-- Flatten statements can return nested entities only (and ignore the higher level objects)
select value
from tweet_ingest
,lateral flatten
(input => raw_status:entities:urls);

-- the same (no difference from query above) 
select value
from tweet_ingest
,table(flatten(raw_status:entities:urls));

--Flatten and return just the hashtag text, CAST the text as VARCHAR
select value:text::varchar as hashtag_used
from tweet_ingest
,lateral flatten
(input => raw_status:entities:hashtags);

--Add the Tweet ID and User ID to the returned table so we could join the hashtag back to it's source tweet
select 
    raw_status:user:name::text as user_name 
    ,raw_status:id as tweet_id
    ,value:text::varchar as hashtag_used
from tweet_ingest
,lateral flatten 
(input => raw_status:entities:hashtags);

-- Create a view of URL data looking normalized
create or replace view social_media_floodgates.public.urls_normalized as(
select 
    raw_status:user:name::text as user_name
    ,raw_status:id as tweet_id
    ,value:display_url::text as url_used
from tweet_ingest
,lateral flatten
(input => raw_status:entities:urls)
);

-- Create a view of hashtag data looking normalized
create or replace view social_media_floodgates.public.HASHTAGS_NORMALIZED as (
select
    raw_status:user:name::text as user_name
    ,raw_status:id as tweet_id
    ,value:text::varchar as hashtag_used
from tweet_ingest
,lateral flatten 
(input => raw_status:entities:hashtags)
);

-- See results
select *
from social_media_floodgates.public.HASHTAGS_NORMALIZED;